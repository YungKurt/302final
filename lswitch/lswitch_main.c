/**
 * NWEN 302 Lab 1
 * Learning Switch Main File
 * Do not edit this file
 *
 * Please report bugs to the author.
 *
 * Copyright (C) 2021 by Alvin Valera <alvin.valera@vuw.ac.nz>
 * All rights reserved.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <ifaddrs.h>

#include <arpa/inet.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ether.h>
#include <linux/if_packet.h>
#include <linux/sockios.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/select.h>
       
#include "lswitch_functions.h"
#include "my_lswitch.h"


#define BUFLEN  1500
#define MAX_INTERFACES  20


/* Holder for last received frame for duplicate detection */
struct last_rx_frame {
    char frame[BUFLEN];
    int len;
};

/* Holder for interface index and name */
struct net_interface {
    int index;
    char name[10];
};

/* Number of interfaces */
int num_interfaces = 3;

/* List of interfaces */
struct net_interface interfaces[MAX_INTERFACES];

/**
 * Get device where frame from
 */ 
char *get_device(int if_index)
{
    for(int i=0; i<num_interfaces; i++) {
        if(interfaces[i].index == if_index)
            return interfaces[i].name;
    }
    return NULL;
}

/**
 * Get all interfaces attached to this node 
 */
void get_all_interfaces()
{
    struct ifaddrs *addrs,*tmp;

    getifaddrs(&addrs);
    tmp = addrs;
    int i = 0;
    while (tmp) {
        if (tmp->ifa_addr && tmp->ifa_addr->sa_family == AF_PACKET && strstr(tmp->ifa_name, "eth")) {
            struct sockaddr_ll *lla = (struct sockaddr_ll *)tmp->ifa_addr;
            interfaces[i].index = lla->sll_ifindex;
            strncpy(interfaces[i].name, tmp->ifa_name, 10);
            i++;
            if(i > num_interfaces) break;
        }
        tmp = tmp->ifa_next;
    }

    freeifaddrs(addrs);    
}

/**
 * Handle an incoming or outgoing packet
 */
void handle_packet(char *buffer, int len, char *device)
{
    struct ethhdr *eth = (struct ethhdr *)buffer;
    if(len < sizeof(struct ethhdr))   
        return;

    /* We don't want to learn from frames not coming from virtual interfaces */
    if(!(eth->h_source[0] == 0 || eth->h_dest[0] == 0))
        return;
    
    /* Tell learning switch about this frame :) */
    my_lswitch_frame_receive(eth->h_source, eth->h_dest, device);
}

/**
 * Display Ethernet header
 * Only used for debugging purpose
 */
void print_eth_header(char* buffer)
{
	struct ethhdr *eth = (struct ethhdr *)buffer;
	
	printf("Received Frame: Ethernet Header\n");
	printf("  |-Destination Address : %.2x:%.2x:%.2x:%.2x:%.2x:%.2x \n", eth->h_dest[0] , eth->h_dest[1] , eth->h_dest[2] , eth->h_dest[3] , eth->h_dest[4] , eth->h_dest[5] );
	printf("  |-Source Address      : %.2x:%.2x:%.2x:%.2x:%.2x:%.2x \n", eth->h_source[0] , eth->h_source[1] , eth->h_source[2] , eth->h_source[3] , eth->h_source[4] , eth->h_source[5] );
	printf("  |-Protocol            : %.4X \n", (unsigned short)ntohs(eth->h_proto));
}


/**
 * The main function.
 * For now, we don't accept command line arguments.
 */
int main(int argc, char *argv[])
{
    int ret = 0;
    int socket_fd;
    char buffer[BUFLEN];
    struct sockaddr_ll saddr;
    struct last_rx_frame last_frame = { 0 };

    /* Check if there is parameter */
    if(argc == 2) {
        sscanf(argv[1], "%d", &num_interfaces);
    }
    if(num_interfaces > MAX_INTERFACES)
        num_interfaces = MAX_INTERFACES;
    
    /* Check if running as root */
    if(geteuid() != 0) {
        printf("Error: this program must be run as root or using sudo.\n");
        return -1;
    }    
    
    /* Get all interfaces and save them for future use */
    get_all_interfaces();
    
    /* Re-configure switch */
    for(int i=0; i<num_interfaces; i++) {
        char cmd[100];
        if(i >= 3) {
            sprintf(cmd, "brctl addif br0 eth%d", i);
            system(cmd);
        }        
        sprintf(cmd, "bridge link set dev eth%d learning off", i);
        system(cmd);
    }
    system("brctl setageing br0 10000");
    
    /* Create raw socket to snoop for packets */
    if((socket_fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) == -1) {
        printf("Error: %s (%d)\n", strerror(errno), errno);
        return errno;
    }


    /* Call my_lswitch_init() */
    my_lswitch_init();
    
    /* Main loop to receive data from tap interface */
    struct sockaddr_ll addr;
    int addrlen = sizeof(addr);
    while (1) {
    
        int len = recvfrom(socket_fd, buffer, BUFLEN, 0, (struct sockaddr*)&addr, (socklen_t*)&addrlen);               
        if (len < 0) {
            printf("Error: Failed to receive packets.\n");
            break;
        } else if (addr.sll_pkttype != PACKET_OUTGOING) {                   
            if(!(len == last_frame.len && memcmp(last_frame.frame, buffer, len) == 0)) {
                char *dev = get_device(addr.sll_ifindex);
                if(!dev) continue;
                printf("Received frame thru interface %s\n", dev);
                //print_eth_header(buffer);
                handle_packet(buffer, len, dev);
            } else {   
                /* printf("- Got a duplicate, discarding.\n"); */
            }
            memcpy(last_frame.frame, buffer, len);
            last_frame.len = len; 
        }
    }
    
    /* Close socket */
    close(socket_fd);

    return 0;
}
